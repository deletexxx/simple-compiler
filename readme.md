## 1.  实现内容

将代码转化为MIPS指令，对于测试样例代码的类型不匹配，不符合设计的文法等错误问题，会检测出错误并进行报错。

* **词法分析器**：读取测试样例中的所有单词，识别单词，分析对应的种别码，并生成token序列，将其传入语法分析

  存储生成的token序列

* **语法分析器**：传入设计好的LL1文法，首先判断传入的文法是否是LL1文法（利用select集），如果是创建分析表，对token序列进行语法分析，判断是否符合设计的文法

  存储生成的LL1分析表、以及对token序列的分析过程

* **语义分析器**：给原本设计的LL1文法加上动作，生成带动作的LL1分析表，然后进行语法分析文法的过程，在这个过程中，利用翻译动作同时生成中间代码（四元式）

  存储四元式，存储带翻译动作的分析过程

* **中间代码优化**：是将四元式生成DAG图进行优化（此部分未完成，不被包括在整个编译器中）

* **寄存器和变量分配**：使用了"$t0-\$t9"，10个寄存器，使用寄存器的三个分配原则——主动释放、选空闲者以及被迫释放来实现寄存器的分配

* **目标代码的生成**：选用了MIPS作为目标代码进行生成，最后能成功运行以下运算：

  * 算数运算：+、-、*、/
  * 布尔运算：&&、||、>、>=、<、<=、==、!=
  * 条件跳转：if、else-if、else
  * 循环语句：while循环

  存储生成的目标代码——MIPS指令

* **符号表系统**：

  贯穿整个过程：

  * 在词法分析生成token序列时，同时进行符号表的创建；
  * 在生成四元式时，需要将生成的临时变量加入符号表中；并且遇到对的标识符的定义，判断是否已经在符号表中（重复定义）；出现标识符就进行判断是否在符号表中（未定义），并且可以进行类型匹配的判断；
  * 生成目标代码时也需要用到。

  存储符号表  

    

  

## 2. 文件介绍

* head：头文件

* CPP：源文件

  * lexical.cpp

    词法分析器的实现

  * LL1.cpp

    语法分析器，使用LL1文法

  * semantic.cpp

    语义分析器，生成四元式

  * symbol.cpp

    符号表

  * DAGoptimize.cpp

    中间代码的优化

  * generator_code.cpp

    由四元式生成目标代码（MIPS指令），有寄存器的分配、活跃信息的计算等内容

  * main.cpp

    主函数，调用上面的源文件，实现编译器的构造

* bin：

  生成的可执行文件

* assert：

  需要输入的信息文件，如g_test.txt就是我们测试的代码，以及设计的LL1文法和LL1翻
  译文法

* process_result：

  存放编译过程生成的文件，如token序列、预测分析表、LL1分析过程、LL1翻译
  过程、生成的符号表以及四元式，还有最终的目标代码(ASM文件)，可以根据文件名确定

* LR0：

  之前实验单独实现的LR0分析（不属于这个编译器的内容，不重要）

最后生成的ASM中的MIPS指令可以在mars4_5中运行。  

  

  

## 3. 编译运行

如果需要编译，在路径./CPP下执行：

```bash
$ g++ -o ../bin/main lexical.cpp LL1.cpp symbol.cpp semantic.cpp DAGoptimize.cpp generate_code.cpp main.cpp
```



然后运行(也可以直接运行编译好的可执行文件)，但是需要注意的是也一定要在文件夹`./CPP`下运行，是设置的路径的问题，否则无法找到一些需要的文件：

```bash
$ ../bin/main.exe 
```

